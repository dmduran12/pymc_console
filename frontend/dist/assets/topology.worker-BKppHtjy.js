(function(){"use strict";const vt={TRANSPORT_FLOOD:0,FLOOD:1,DIRECT:2,TRANSPORT_DIRECT:3};function kt(c){return c===vt.FLOOD||c===vt.TRANSPORT_FLOOD}function Tt(c){return c===vt.DIRECT||c===vt.TRANSPORT_DIRECT}function rt(c){return c.startsWith("0x")||c.startsWith("0X")?c.slice(2,4).toUpperCase():c.slice(0,2).toUpperCase()}function _t(c,l){let i=c.forwarded_path??c.original_path;if(typeof i=="string")try{i=JSON.parse(i)}catch{return null}if(!i||!Array.isArray(i)||i.length===0)return null;const g=i.map(S=>String(S).toUpperCase()),b=l?rt(l):null,C=g[g.length-1],M=b!==null&&C===b,u=M?g.slice(0,-1):[...g];return{effective:u,original:g,hadLocal:M,effectiveLength:u.length}}function Et(c,l){return l-c}function Ce(c){return c}function Gt(c,l){const i=c.toUpperCase();return l.startsWith("0x")||l.startsWith("0X")?l.slice(2).toUpperCase().startsWith(i):l.toUpperCase().startsWith(i)}const nt={VERY_CLOSE:500,CLOSE:2e3,MEDIUM:5e3,FAR:1e4,VERY_FAR:2e4},gt={VERY_CLOSE:1,CLOSE:.8,MEDIUM:.6,FAR:.4,VERY_FAR:.2,BEYOND:.1};function St(c,l,i,g){const C=(i-c)*Math.PI/180,M=(g-l)*Math.PI/180,u=Math.sin(C/2)*Math.sin(C/2)+Math.cos(c*Math.PI/180)*Math.cos(i*Math.PI/180)*Math.sin(M/2)*Math.sin(M/2);return 6371e3*(2*Math.atan2(Math.sqrt(u),Math.sqrt(1-u)))}function Yt(c){return c<nt.VERY_CLOSE?gt.VERY_CLOSE:c<nt.CLOSE?gt.CLOSE:c<nt.MEDIUM?gt.MEDIUM:c<nt.FAR?gt.FAR:c<nt.VERY_FAR?gt.VERY_FAR:gt.BEYOND}function Bt(c){if(c.contact_type){const l=c.contact_type.toLowerCase();if(l==="repeater"||l==="rep")return!0;if(l==="companion"||l==="client"||l==="cli"||l==="room server"||l==="room_server"||l==="room"||l==="server")return!1}return c.is_repeater===!0?!0:(c.is_repeater===!1,!1)}function Wt(c){const l={};for(const[i,g]of Object.entries(c))Bt(g)&&(l[i]=g);return l}const Pt={position:.15,cooccurrence:.15,geographic:.35,recency:.35},bt=5,Kt=336,Vt=12;function zt(c,l){if(!c||c<=0)return .1;const g=(Math.floor(Date.now()/1e3)-c)/3600;return g<0?1:Math.exp(-g/Vt)}function qt(c){return!c||c<=0?!1:(Math.floor(Date.now()/1e3)-c)/3600>Kt}function $t(c,l,i,g,b){const C=new Map,M=Wt(l),u=new Map,S=g!==void 0&&b!==void 0&&(g!==0||b!==0);if(i){const o=rt(i),e={hash:i,prefix:o,positionCounts:new Array(bt).fill(0),totalAppearances:0,typicalPosition:0,positionConsistency:0,adjacentPrefixCounts:new Map,totalAdjacentObservations:0,latitude:g,longitude:b,distanceToLocal:0,srcGeoEvidenceScore:0,srcGeoEvidenceCount:0,lastSeenTimestamp:Math.floor(Date.now()/1e3),recencyScore:1,positionScore:0,cooccurrenceScore:0,geographicScore:1,combinedScore:0};u.set(o,[e])}for(const[o,e]of Object.entries(M)){const s=rt(o),p=e.last_seen??0;if(qt(p))continue;let f;const P=e.zero_hop===!0;S&&e.latitude&&e.longitude&&(e.latitude!==0||e.longitude!==0)&&(f=St(g,b,e.latitude,e.longitude));let d=.2;f!==void 0?f<nt.VERY_CLOSE?d=1:f<nt.CLOSE?d=.8:f<nt.MEDIUM?d=.6:f<nt.FAR?d=.4:f<nt.VERY_FAR?d=.2:d=.1:e.latitude&&e.longitude&&(d=.5),P&&(d=Math.max(d,.95));const R=zt(p),x={hash:o,prefix:s,positionCounts:new Array(bt).fill(0),totalAppearances:0,typicalPosition:0,positionConsistency:0,adjacentPrefixCounts:new Map,totalAdjacentObservations:0,latitude:e.latitude,longitude:e.longitude,distanceToLocal:f,srcGeoEvidenceScore:0,srcGeoEvidenceCount:0,lastSeenTimestamp:p,recencyScore:R,positionScore:0,cooccurrenceScore:0,geographicScore:d,combinedScore:0},_=u.get(s)||[];_.push(x),u.set(s,_)}for(const o of c){const e=_t(o,i);if(!e||e.effectiveLength===0)continue;const s=e.effective,p=o.src_hash,f=p?l[p]:void 0,P=(f==null?void 0:f.latitude)&&(f==null?void 0:f.longitude)&&(f.latitude!==0||f.longitude!==0);for(let d=0;d<s.length;d++){const R=s[d],x=u.get(R);if(!x)continue;const _=Et(d,e.effectiveLength),N=Math.min(_-1,bt-1);for(const E of x){if(E.positionCounts[N]++,E.totalAppearances++,_===1&&x.length>1&&P&&E.latitude&&E.longitude){const O=St(f.latitude,f.longitude,E.latitude,E.longitude);let T=0;O<500?T=1:O<2e3?T=.8:O<5e3?T=.5:O<1e4?T=.3:T=.1,E.distanceToLocal!==void 0&&(E.distanceToLocal<500?T*=1.2:E.distanceToLocal<2e3?T*=1:T*=.8),E.srcGeoEvidenceScore+=T,E.srcGeoEvidenceCount++}if(d>0&&x.length>1&&E.latitude&&E.longitude){const O=d-1,T=s[O],F=u.get(T);if(F&&F.length>0){let q,L,I=0;if(F.length===1){const w=F[0];w.latitude&&w.longitude&&(q=w.latitude,L=w.longitude,I=1)}else{const w=[...F].sort((r,m)=>m.combinedScore-r.combinedScore),v=w[0],a=w[1];if(v.latitude&&v.longitude&&v.combinedScore>0){const r=a?(v.combinedScore-a.combinedScore)/v.combinedScore:1;I=Math.min(1,r+.3),I>.4&&(q=v.latitude,L=v.longitude)}}if(q!==void 0&&L!==void 0){const w=St(E.latitude,E.longitude,q,L);let v=0;w<500?v=1:w<2e3?v=.8:w<5e3?v=.5:w<1e4?v=.3:v=.1,v*=I,E.srcGeoEvidenceScore+=v,E.srcGeoEvidenceCount++}}}if(_>1&&x.length>1&&E.latitude&&E.longitude){const O=d+1;if(O<s.length){const T=s[O],F=u.get(T);if(F&&F.length>0){let q,L,I=0;if(F.length===1){const w=F[0];w.latitude&&w.longitude&&(q=w.latitude,L=w.longitude,I=1)}else{const w=[...F].sort((r,m)=>m.combinedScore-r.combinedScore),v=w[0],a=w[1];if(v.latitude&&v.longitude&&v.combinedScore>0){const r=a?(v.combinedScore-a.combinedScore)/v.combinedScore:1;I=Math.min(1,r+.3),I>.4&&(q=v.latitude,L=v.longitude)}}if(q!==void 0&&L!==void 0){const w=St(E.latitude,E.longitude,q,L);let v=0;w<500?v=1:w<2e3?v=.8:w<5e3?v=.5:w<1e4?v=.3:v=.1,v*=I,E.srcGeoEvidenceScore+=v,E.srcGeoEvidenceCount++}}}}if(d>0){const O=s[d-1];E.adjacentPrefixCounts.set(O,(E.adjacentPrefixCounts.get(O)||0)+1),E.totalAdjacentObservations++}if(d<s.length-1){const O=s[d+1];E.adjacentPrefixCounts.set(O,(E.adjacentPrefixCounts.get(O)||0)+1),E.totalAdjacentObservations++}}}}let h=1,n=1;for(const o of u.values())for(const e of o)h=Math.max(h,e.totalAppearances),n=Math.max(n,e.totalAdjacentObservations);for(const o of u.values())for(const e of o){if(e.totalAppearances>0){let s=0,p=1;for(let P=0;P<bt;P++)e.positionCounts[P]>s&&(s=e.positionCounts[P],p=P+1);e.typicalPosition=p,e.positionConsistency=s/e.totalAppearances;const f=e.totalAppearances/h;e.positionScore=e.positionConsistency*.6+f*.4}if(e.totalAdjacentObservations>0&&(e.cooccurrenceScore=e.totalAdjacentObservations/n),e.combinedScore=e.positionScore*Pt.position+e.cooccurrenceScore*Pt.cooccurrence+e.geographicScore*Pt.geographic+e.recencyScore*Pt.recency,e.srcGeoEvidenceCount>0){const s=e.srcGeoEvidenceScore/e.srcGeoEvidenceCount,p=Math.min(e.srcGeoEvidenceCount/50,1),f=s*p*.3;e.combinedScore+=f}}for(const[o,e]of u){e.sort((d,R)=>R.combinedScore-d.combinedScore);const s=e.length>0?e[0].hash:null;let p=0;if(e.length===1)p=1;else if(e.length>1){const d=e[0].combinedScore,R=e[1].combinedScore;d>0&&(p=Math.min(1,(d-R)/d)),e[0].totalAppearances>e[1].totalAppearances*2&&(p=Math.min(1,p+.2));const x=0,_=e[0].positionCounts[x]||0,N=e[1].positionCounts[x]||0,E=_+N;if(E>=20&&_>=10){const L=_/E;if(L>=.8){const I=.3+(L-.8)*1.5;p=Math.min(1,p+I)}}const O=e.reduce((L,I)=>L+I.combinedScore,0);if(O>0){const L=[],I=e.reduce((r,m)=>r+(m.positionCounts[0]||0),0);for(const r of e){const m=r.combinedScore/O,k=I*m;L.push(k)}const w=L[0],v=L[1]||0,a=w+v;if(a>=20&&w>=10){const r=w/a;if(r>=.6){const m=.2+(r-.6)*1;p=Math.min(1,p+m)}}}const T=e[0].srcGeoEvidenceScore,F=e[1].srcGeoEvidenceScore;if(e[0].srcGeoEvidenceCount>=10&&T>F*1.5){const L=F>0?T/(T+F):1,I=Math.min(.3,(L-.5)*.6);p=Math.min(1,p+I)}}const f=new Map;for(let d=1;d<=bt;d++){const R=[...e].sort((x,_)=>{const N=x.positionCounts[d-1]||0;return(_.positionCounts[d-1]||0)-N});if(R.length>0&&R[0].positionCounts[d-1]>0){const x=R[0];let _=1;if(R.length>1){const N=x.positionCounts[d-1],E=R[1].positionCounts[d-1]||0,O=N+E;_=O>0?N/O:0}f.set(d,{hash:x.hash,confidence:_})}}const P={prefix:o,candidates:e,bestMatch:s,confidence:p,isUnambiguous:e.length===1,bestMatchForPosition:f};C.set(o,P)}return C}function Mt(c,l,i){const g=l.toUpperCase(),b=c.get(g);if(!b||b.candidates.length===0)return{hash:null,confidence:0};if(i!=null&&i.isLastHop)return{hash:b.bestMatch,confidence:b.confidence};if((i==null?void 0:i.position)===1)return{hash:b.bestMatch,confidence:b.confidence};if(i!=null&&i.position&&b.bestMatchForPosition.has(i.position)){const C=b.bestMatchForPosition.get(i.position),M=Math.max(C.confidence,b.confidence);return{hash:C.hash,confidence:M}}if(i!=null&&i.adjacentPrefixes&&i.adjacentPrefixes.length>0){let C=b.bestMatch,M=0;for(const u of b.candidates){let S=0;for(const n of i.adjacentPrefixes)S+=u.adjacentPrefixCounts.get(n.toUpperCase())||0;const h=u.combinedScore+S/Math.max(1,u.totalAdjacentObservations)*.3;h>M&&(M=h,C=u.hash)}return{hash:C,confidence:b.confidence}}return{hash:b.bestMatch,confidence:b.confidence}}function Xt(c,l){return`${l}:${c.join(">")}`}function Zt(c,l){return`${c}→${l}`}function It(c){const l=c.route??c.route_type;return kt(l)?"flood":Tt(l)?"direct":"unknown"}function Jt(c,l){const i=new Map,g=new Map;let b=0;for(const u of c){if(!u.src_hash)continue;const S=u.original_path??u.forwarded_path;if(!S||!Array.isArray(S)||S.length===0)continue;const h=S.map(f=>typeof f=="string"?f.toUpperCase().slice(0,2):String(f).toUpperCase().slice(0,2)),n=l||"unknown",o=u.src_hash,e=Xt(h,o);let s=i.get(e);s||(s={id:e,hops:h,srcHash:o,dstHash:n,observationCount:0,firstSeen:u.timestamp,lastSeen:u.timestamp,routeType:It(u),hopCount:h.length},i.set(e,s)),s.observationCount++,s.lastSeen=Math.max(s.lastSeen,u.timestamp),s.firstSeen=Math.min(s.firstSeen,u.timestamp),b++,It(u)==="direct"&&s.routeType!=="direct"&&(s.routeType="direct")}const C=Array.from(i.values());for(const u of C){const S=Zt(u.srcHash,u.dstHash),h=g.get(S)||[];h.push(u),g.set(S,h)}for(const u of g.values())u.sort((S,h)=>h.observationCount-S.observationCount);const M=new Map;for(const[u,S]of g)S.length>0&&M.set(u,S[0]);return{paths:C,byEndpoints:g,canonicalPaths:M,totalObservations:b,uniquePathCount:C.length}}function Qt(c){return{paths:c.paths,byEndpointsEntries:Array.from(c.byEndpoints.entries()),canonicalPathsEntries:Array.from(c.canonicalPaths.entries()),totalObservations:c.totalObservations,uniquePathCount:c.uniquePathCount}}const Lt=5,te=.9,wt=.6,ee=.4,oe=wt,Nt=100,xt=100,At=1e4,Ft=.3,ne=.5,se=2;function ie(c,l,i,g,b,C){const M=new Map,u=i!==void 0&&g!==void 0&&(i!==0||g!==0);for(const[n,o]of Object.entries(l)){let e=null,s=.5;u&&o.latitude&&o.longitude&&(o.latitude!==0||o.longitude!==0)&&(e=St(i,g,o.latitude,o.longitude),s=Yt(e)),o.zero_hop&&(s=Math.max(s,.9)),M.set(n,{hash:n,frequency:0,directForwardCount:0,distanceMeters:e,proximityScore:s,hopPositionCounts:[0,0,0,0,0],avgHopDistance:0,typicalHopPosition:0,hopConsistencyScore:0,frequencyScore:0,combinedScore:0,avgDisambiguationConfidence:0,collisionCount:0,resolutionCount:0})}const S=new Map;for(const n of c){const o=_t(n,b);if(o&&o.effectiveLength>=1){const e=o.effective;for(let s=0;s<e.length;s++){const p=e[s],f=Et(s,o.effectiveLength);if(C){const P=Mt(C,p,{position:f,adjacentPrefixes:[...s>0?[e[s-1]]:[],...s<e.length-1?[e[s+1]]:[]],isLastHop:f===1});if(P.hash){const d=M.get(P.hash);if(d){d.frequency++,d.resolutionCount++;const R=S.get(P.hash)||0;S.set(P.hash,R+P.confidence);const x=C.get(p.toUpperCase());x&&!x.isUnambiguous&&d.collisionCount++;const _=Math.min(f-1,4);d.hopPositionCounts[_]++,f===1&&d.directForwardCount++}}}else for(const[P,d]of M)if(Gt(p,P)){d.frequency++;const R=Math.min(f-1,4);d.hopPositionCounts[R]++,f===1&&d.directForwardCount++}}}if((!o||o.effectiveLength===0)&&n.src_hash){const e=M.get(n.src_hash);if(e){e.frequency++,e.directForwardCount++,e.hopPositionCounts[0]++,e.resolutionCount++;const s=S.get(n.src_hash)||0;S.set(n.src_hash,s+1)}}}let h=0;for(const n of M.values())h=Math.max(h,n.frequency);for(const n of M.values()){let o=0,e=0,s=0,p=1;for(let P=0;P<n.hopPositionCounts.length;P++){const d=n.hopPositionCounts[P],R=P+1;o+=d,e+=d*R,d>s&&(s=d,p=R)}n.avgHopDistance=o>0?e/o:0,n.typicalHopPosition=p,o>0&&s>0&&(n.hopConsistencyScore=s/o),n.frequencyScore=h>0?n.frequency/h:0;const f=S.get(n.hash)||0;n.avgDisambiguationConfidence=n.resolutionCount>0?f/n.resolutionCount:0,n.combinedScore=n.proximityScore*.3+n.hopConsistencyScore*.3+n.frequencyScore*.4}return M}function Rt(c,l){return[c,l].sort().join("-")}function ce(c,l,i=1){if(c.length<3)return{loops:[],loopEdgeKeys:new Set};const g=new Map,b=new Map;for(const h of c)b.set(h.key,h),g.has(h.fromHash)||g.set(h.fromHash,new Set),g.has(h.toHash)||g.set(h.toHash,new Set),g.get(h.fromHash).add(h.toHash),g.get(h.toHash).add(h.fromHash);const C=[],M=new Set,u=new Set;function S(h,n,o){if(h===n)return[h];const e=new Set([h]),s=[{node:h,path:[h]}];for(;s.length>0;){const{node:p,path:f}=s.shift(),P=g.get(p);if(P){for(const d of P)if(Rt(p,d)!==o){if(d===n)return[...f,d];e.has(d)||(e.add(d),s.push({node:d,path:[...f,d]}))}}}return null}for(const h of c){const n=S(h.fromHash,h.toHash,h.key);if(n&&n.length>=2){const o=n,e=[h.key];for(let x=0;x<n.length-1;x++){const _=Rt(n[x],n[x+1]);e.push(_)}const s=[...o].sort().join(",");if(u.has(s))continue;u.add(s);let p=0,f=1/0;for(const x of e){const _=b.get(x);_&&(p+=_.certainCount,f=Math.min(f,_.certainCount),M.add(x))}const P=e.length>0?p/e.length:0,d=l?o.includes(l):!1,R={id:`loop-${C.length}`,edgeKeys:e,nodes:o,size:e.length,avgCertainCount:P,minCertainCount:f===1/0?0:f,includesLocal:d,strength:i>0?f===1/0?0:f/i:0};C.push(R)}}return C.sort((h,n)=>h.includesLocal!==n.includesLocal?h.includesLocal?-1:1:n.strength-h.strength),{loops:C,loopEdgeKeys:M}}function ae(c,l,i,g,b,C){const M=new Map;if(c.length===0||i.length===0)return M;const u=5,S=.2,h=.7,n=.28,o=0,e=3,s=a=>{const r=Math.round(a/S)*S;return Math.max(o,Math.min(e,r))},p=a=>Math.floor(u*a),f=new Set;for(const a of c)f.add(a.fromHash),f.add(a.toHash);const P=i.map(a=>a.timestamp).filter(a=>a!==void 0&&a>0).sort((a,r)=>a-r),d=P.length>=2?(P[P.length-1]-P[0])/60:1,R=new Map;for(const a of c)R.has(a.fromHash)||R.set(a.fromHash,[]),R.has(a.toHash)||R.set(a.toHash,[]),R.get(a.fromHash).push(a),R.get(a.toHash).push(a);const x=new Set;for(const a of c)a.isLoopEdge&&x.add(a.key);const _=new Set;for(const[,a]of g.canonicalPaths)for(const r of a.hops)_.add(r.toUpperCase());const N=new Map;for(const a of f){const r=R.get(a)||[];if(r.length===0)continue;const m=a.startsWith("0x")?a.slice(2,4).toUpperCase():a.slice(0,2).toUpperCase(),k=new Set;let $=0,K=0,X=0,dt=0,ut=0,tt=0,J=0;for(const B of r){const et=B.fromHash===a?B.toHash:B.fromHash;k.add(et),$+=B.packetCount,K+=B.certainCount,X=Math.max(X,B.certainCount),dt+=B.symmetryRatio,ut+=B.floodCount,B.isDirectPathEdge&&tt++,x.has(B.key)&&J++}const Q=k.size,lt=r.length>0?dt/r.length:0,st=r.length>0?K/r.length:0,ht=g.paths.filter(B=>B.hops.some(et=>et.toUpperCase()===m)),it=ht.length;let pt=0;for(const[,B]of g.canonicalPaths)B.hops.some(et=>et.toUpperCase()===m)&&pt++;const Ct=ht.length>0?ht.reduce((B,et)=>B+et.hopCount,0)/ht.length:0;N.set(a,{neighborCount:Q,totalEdgePackets:$,maxEdgeCertainCount:X,avgEdgeCertainCount:st,avgSymmetry:lt,forwardingBurden:0,floodForwardRatio:$>0?ut/$:0,pathCount:it,canonicalPathCount:pt,avgPathLength:Ct,loopParticipation:r.length>0?J/r.length:0,isInLoop:J>0,edgeDensity:0,trafficRate:d>0?$/d:0,directPathEdgeRatio:r.length>0?tt/r.length:0})}const E=[],O=[],T=[],F=[];for(const[,a]of N)a.totalEdgePackets>=xt&&(E.push(a.totalEdgePackets),O.push(a.neighborCount),T.push(a.pathCount),F.push(a.trafficRate));E.sort((a,r)=>a-r),O.sort((a,r)=>a-r),T.sort((a,r)=>a-r),F.sort((a,r)=>a-r);const q=(a,r)=>{if(a.length===0)return .5;const m=a.findIndex(k=>k>=r);return m===-1?1:m===0?0:m/a.length},L=O.length>0?Math.max(...O):1;for(const[,a]of N)a.forwardingBurden=q(E,a.totalEdgePackets),a.edgeDensity=L>0?a.neighborCount/L:0;const I=new Map;for(const a of f){const r=N.get(a);if(!r||r.totalEdgePackets<xt)continue;const m=a.startsWith("0x")?a.slice(2,4).toUpperCase():a.slice(0,2).toUpperCase(),k=r.forwardingBurden,$=q(O,r.neighborCount),K=r.avgSymmetry*.3,X=Math.min(1,$+K),dt=g.canonicalPaths.size>0?r.canonicalPathCount/g.canonicalPaths.size:0,ut=q(T,r.pathCount),tt=dt*.6+ut*.4,J=r.loopParticipation,Q=k*.3+X*.3+tt*.2+J*.2;let lt=Q*e;Q<.1&&r.neighborCount<=2?lt=0:lt<.2&&(lt=.2);let st;Q>=.7&&r.neighborCount>=4?st="backbone":r.neighborCount>=4?st="hub":Q>=.3&&r.neighborCount>=2?st="relay":st="edge";const it=g.paths.filter(ct=>ct.hops.some(at=>at.toUpperCase()===m)).flatMap(ct=>{const at=ct.hops.findIndex(Ot=>Ot.toUpperCase()===m);return at>=0?[at+1]:[]}),pt=it.length>0?it.reduce((ct,at)=>ct+at,0)/it.length:0;let Ct=0;it.length>1&&(Ct=it.reduce((ct,at)=>ct+Math.pow(at-pt,2),0)/it.length);const B=Math.min(r.avgEdgeCertainCount/10,1),et=Math.min(i.length/At,1),mt=r.avgSymmetry,Ht=B*.3+et*.3+mt*.4;let ft;i.length<xt?ft="insufficient":i.length<At||r.avgSymmetry<Ft?ft="low":i.length<At*2||r.avgSymmetry<ne?ft="medium":ft="high",I.set(a,{compositeScore:Q,rawFloodDelay:lt,networkRole:st,collisionRisk:X,floodParticipationRate:r.floodForwardRatio,avgPathPosition:pt,pathPositionVariance:Ct,pathDiversity:r.pathCount,trafficIntensity:r.trafficRate,confidence:Ht,observationSymmetry:r.avgSymmetry,dataConfidence:ft,factors:{forwarding:k,collision:X,criticality:tt,redundancy:J}})}const w=new Map;for(const[a,r]of I){const m=p(s(r.rawFloodDelay));w.has(m)||w.set(m,[]),w.get(m).push(a)}const v=new Map;for(const[,a]of w){if(a.length<=1){if(a.length===1){const m=a[0],k=I.get(m);v.set(m,s(k.rawFloodDelay))}continue}const r=[...a].sort((m,k)=>{const $=I.get(m),K=I.get(k);return $.compositeScore-K.compositeScore});for(let m=0;m<r.length;m++){const k=r[m],$=I.get(k),K=m%3*S;v.set(k,s($.rawFloodDelay+K))}}for(const a of f){const r=N.get(a);if(!r||r.totalEdgePackets<xt){M.set(a,{floodDelaySec:0,directDelaySec:0,floodSlots:0,directSlots:0,txDelayFactor:0,directTxDelayFactor:0,trafficIntensity:0,directNeighborCount:(r==null?void 0:r.neighborCount)??0,collisionRisk:0,confidence:0,insufficientData:!0,networkRole:"edge",rationale:"Insufficient data (<100 packets observed)",adjustment:"stable",avgPathPosition:0,pathPositionVariance:0,floodParticipationRate:0,pathDiversity:0,positionDelayMs:0,observationSymmetry:(r==null?void 0:r.avgSymmetry)??0,dataConfidence:"insufficient"});continue}const m=I.get(a),k=v.get(a)??s(m.rawFloodDelay),$=k*n,K=s($),X=p(k),dt=p(K);let tt={backbone:`Backbone: ${r.neighborCount} neighbors, ${Math.round(r.avgSymmetry*100)}% symmetric`,hub:`Hub: ${r.neighborCount} neighbors`,relay:`Relay: ${Math.round(r.avgSymmetry*100)}% symmetric traffic`,edge:"Edge node"}[m.networkRole];m.observationSymmetry>=.6?tt+=". High bidirectional visibility (+1 slot)":m.observationSymmetry<Ft&&(tt+=". ⚠️ Low symmetry (possible observer bias)"),m.dataConfidence==="low"&&(tt+=". Limited data");let J;X>p(h)?J="increase":X<p(h)?J="decrease":J="stable",M.set(a,{floodDelaySec:k,directDelaySec:K,floodSlots:X,directSlots:dt,txDelayFactor:k,directTxDelayFactor:K,trafficIntensity:Math.round(m.trafficIntensity*10)/10,directNeighborCount:r.neighborCount,collisionRisk:Math.round(m.collisionRisk*100)/100,confidence:m.confidence,insufficientData:!1,networkRole:m.networkRole,rationale:tt,adjustment:J,avgPathPosition:Math.round(m.avgPathPosition*10)/10,pathPositionVariance:Math.round(m.pathPositionVariance*100)/100,floodParticipationRate:Math.round(m.floodParticipationRate*100)/100,pathDiversity:m.pathDiversity,positionDelayMs:0,observationSymmetry:Math.round(m.observationSymmetry*100)/100,dataConfidence:m.dataConfidence})}return M}function re(c,l){const i=new Map,g=new Map(l.map(C=>[C.key,C]));for(const C of l)i.set(C.key,0);if(c.paths.length===0)return i;for(const C of c.paths)for(let M=0;M<C.hops.length-1;M++){const u=C.hops[M],S=C.hops[M+1];for(const h of l){const n=rt(h.fromHash),o=rt(h.toHash);if(n===u&&o===S||n===S&&o===u){const s=i.get(h.key)||0;i.set(h.key,s+C.observationCount);break}}}const b=Math.max(...i.values(),1);for(const[C,M]of i)i.set(C,M/b);for(const[C,M]of i){const u=g.get(C);if(u){const S=.5+.5*u.symmetryRatio;i.set(C,M*S)}}return i}function fe(c,l=3,i=.3){return[...c.entries()].filter(([,b])=>b>=i).sort((b,C)=>C[1]-b[1]).slice(0,l).map(([b])=>b)}function de(c,l){const i=new Map,g=[];if(c.paths.length===0)return{nodeMobility:i,mobileNodes:g};const b=3600*1e3,C=c.paths.map(n=>n.lastSeen).sort((n,o)=>n-o),M=C[0],u=C[C.length-1],S=Math.ceil((u-M)/b)||1,h=new Map;for(const n of c.paths){const o=Math.floor((n.lastSeen-M)/b);for(const e of n.hops){let s=e;for(const[f]of Object.entries(l))if((f.startsWith("0x")?f.slice(2,4).toUpperCase():f.slice(0,2).toUpperCase())===e.toUpperCase()){s=f;break}let p=h.get(s);p||(p={paths:new Set,firstSeen:n.firstSeen,lastSeen:n.lastSeen,windowPresence:new Set},h.set(s,p)),p.paths.add(n.id),p.firstSeen=Math.min(p.firstSeen,n.firstSeen),p.lastSeen=Math.max(p.lastSeen,n.lastSeen),p.windowPresence.add(o)}}for(const[n,o]of h){const e=o.paths.size,s=o.lastSeen-o.firstSeen,p=s>0?s/(1e3*60*60):0,f=S>0?o.windowPresence.size/S:1,P=1-f,d=Math.min(e/10,1),R=P*(1-d*.5),x=R>.3,_={hash:n,pathVolatility:R,pathDiversity:e,avgPathLifespanHours:p,isMobile:x,lastSeen:o.lastSeen,activeWindowRatio:f};i.set(n,_),x&&g.push(n)}return g.sort((n,o)=>{var p,f;const e=((p=i.get(n))==null?void 0:p.pathVolatility)??0;return(((f=i.get(o))==null?void 0:f.pathVolatility)??0)-e}),{nodeMobility:i,mobileNodes:g}}function le(c,l,i,g=20){const b=[];if(c.paths.length===0)return b;const C=new Map;for(const o of l){const e=rt(o.fromHash),s=rt(o.toHash);C.set(`${e}>${s}`,o),C.set(`${s}>${e}`,o)}const M=new Set;for(const o of i)M.add(rt(o));const u=new Map;for(const o of c.paths){if(o.hops.length===0)continue;const e=o.hops[o.hops.length-1],s=u.get(e)||[];s.push(o.id),u.set(e,s)}const S=[...c.paths].sort((o,e)=>e.observationCount-o.observationCount),h=Date.now(),n=3600*1e3;for(const o of S.slice(0,g)){if(o.hops.length<2)continue;let e=0,s=1/0,p=null,f=0,P=!1;for(let r=0;r<o.hops.length-1;r++){const m=o.hops[r],k=o.hops[r+1],$=`${m}>${k}`,K=C.get($);if(K){const X=K.packetCount>0?K.certainCount/K.packetCount:0;e+=X,f++,X<s&&(s=X,p=K.key)}else e+=.1,f++,.1<s&&(s=.1,p=Rt(m,k));(M.has(m)||M.has(k))&&(P=!0)}const d=f>0?e/f:0,R=s===1/0?0:s,x=(h-o.lastSeen)/n,_=Math.exp(-x/24),N=o.observationCount>10&&x<12?.5+(1-x/12)*.5:x>48?-.5:0,E=o.hops[o.hops.length-1],O=u.get(E)||[],T=Math.max(0,O.length-1),F=o.routeType==="direct"?20:30,q=o.hops.length*F,L=d*.4,I=_*.3,w=(N+1)/2*.15,v=Math.min(T/3,1)*.15,a=Math.round((L+I+w+v)*100)/100;b.push({pathKey:o.id,hops:[...o.hops],healthScore:a,weakestLinkKey:p,weakestLinkConfidence:Math.round(R*100)/100,avgEdgeCertainty:Math.round(d*100)/100,observationTrend:Math.round(N*100)/100,alternatePathsCount:T,estimatedLatencyMs:q,observationCount:o.observationCount,routeType:o.routeType==="unknown"?"mixed":o.routeType,lastSeen:o.lastSeen,involvesHub:P})}return b.sort((o,e)=>e.healthScore-o.healthScore),b}function ue(c,l,i,g=ee,b,C,M){const u=[...c].sort((t,y)=>(t.timestamp??0)-(y.timestamp??0)),S=$t(u,l,i,b,C),h=ie(u,l,b,C,i,S),n=i?rt(i):null,o=new Map;for(const[t,y]of h)o.set(t,y.combinedScore);const e=new Map,s=new Map,p=new Map,f=new Map,P=new Map,d=Math.floor(Date.now()/1e3),R=12,x=t=>{if(!t||t<=0)return .1;const y=(d-t)/3600;return y<0?1:Math.exp(-y/R)},_=(t,y,D,H,U,V,A)=>{const j=Rt(t,y),G=e.get(j),[ot,Y]=t<y?[t,y]:[y,t],W=t===ot,z=kt(V)||V===void 0,Z=Tt(V),Dt=x(A);if(G)G.count++,G.confidenceSum+=D,G.recencySum+=Dt,G.minHopDistance=Math.min(G.minHopDistance,U),U<G.hopDistanceCounts.length&&G.hopDistanceCounts[U]++,H?G.certainCount++:G.uncertainCount++,W?G.forwardCount++:G.reverseCount++,z?G.floodCount++:Z&&G.directCount++;else{const yt=[0,0,0,0,0,0,0,0,0,0];U<yt.length&&yt[U]++,e.set(j,{fromHash:ot,toHash:Y,key:j,count:1,confidenceSum:D,minHopDistance:U,hopDistanceCounts:yt,certainCount:H?1:0,uncertainCount:H?0:1,forwardCount:W?1:0,reverseCount:W?0:1,floodCount:z?1:0,directCount:Z?1:0,recencySum:Dt})}};for(const t of u){const y=_t(t,i);if(!y)continue;const D=y.effective,H=y.effectiveLength,U=y.original,V=new Set;if(t.src_hash&&U.length>=1){const A=U[0],j=Mt(S,A,{position:H,adjacentPrefixes:U.length>1?[U[1]]:[]}),G=t.src_hash;if(j.hash&&j.hash!==G){const ot=Object.keys(l).includes(G),Y=j.confidence>=oe&&ot,W=j.confidence*(ot?1:.8),z=H+1,Z=t.route??t.route_type;_(G,j.hash,W,Y,z,Z,t.timestamp),V.add(G),V.add(j.hash)}}if(i&&H>=1){const A=H-1,j=D[A],ot=(t.type??t.payload_type)===4;if(ot){const W=P.get(j);W?(W.count++,typeof t.rssi=="number"&&!isNaN(t.rssi)&&(W.rssiSum+=t.rssi,W.rssiCount++),typeof t.snr=="number"&&!isNaN(t.snr)&&(W.snrSum+=t.snr,W.snrCount++),W.lastSeen=Math.max(W.lastSeen,t.timestamp??0)):P.set(j,{prefix:j,count:1,rssiSum:typeof t.rssi=="number"&&!isNaN(t.rssi)?t.rssi:0,rssiCount:typeof t.rssi=="number"&&!isNaN(t.rssi)?1:0,snrSum:typeof t.snr=="number"&&!isNaN(t.snr)?t.snr:0,snrCount:typeof t.snr=="number"&&!isNaN(t.snr)?1:0,lastSeen:t.timestamp??0,resolvedHashes:new Map})}const Y=Mt(S,j,{position:1,adjacentPrefixes:A>0?[D[A-1]]:[],isLastHop:!0});if(ot&&Y.hash){const W=P.get(j);if(W){const z=W.resolvedHashes.get(Y.hash);z?(z.count++,z.confidenceSum+=Y.confidence):W.resolvedHashes.set(Y.hash,{count:1,confidenceSum:Y.confidence})}}if(Y.hash&&Y.hash!==i){const z=Y.confidence,Z=t.route??t.route_type;_(Y.hash,i,z,!0,0,Z,t.timestamp),V.add(Y.hash),V.add(i),f.set(Y.hash,(f.get(Y.hash)||0)+1)}}for(let A=0;A<H-1;A++){const j=D[A],G=D[A+1],ot=Et(A,H),Y=Et(A+1,H),W=Y===1,z=Mt(S,j,{position:ot,adjacentPrefixes:[...A>0?[D[A-1]]:[],D[A+1]]}),Z=Mt(S,G,{position:Y,adjacentPrefixes:[D[A],...A+2<H?[D[A+2]]:[]],isLastHop:W});if(!z.hash||!Z.hash||z.hash===Z.hash)continue;const Dt=z.confidence>=wt&&Z.confidence>=wt,yt=Z.confidence>=te,he=W&&Z.confidence>=wt,Ut=Dt||yt||he;V.add(z.hash),V.add(Z.hash),A>0&&A<H-1&&p.set(z.hash,(p.get(z.hash)||0)+1);const jt=yt?Z.confidence:z.confidence*Z.confidence;if(!Ut&&jt<g)continue;const pe=Y,ge=t.route??t.route_type;_(z.hash,Z.hash,jt,Ut,pe,ge,t.timestamp)}for(const A of V)s.set(A,(s.get(A)||0)+1)}const N=new Map;let E=0;for(const[t,y]of s){const D=p.get(t)||0,H=y>0?D/y:0;N.set(t,H),E=Math.max(E,H)}if(E>0)for(const[t,y]of N)N.set(t,y/E);const O=Math.max(Lt,Math.floor(c.length*.01)),T=new Set,F=new Map;for(const t of e.values()){const D=t.forwardCount+t.reverseCount>0?Math.min(t.forwardCount,t.reverseCount)/Math.max(t.forwardCount,t.reverseCount):0;for(const H of[t.fromHash,t.toHash]){const U=F.get(H)||{sum:0,count:0};U.sum+=D,U.count++,F.set(H,U)}}const q=[...N.entries()].filter(([t,y])=>(s.get(t)||0)>=O).map(([t,y])=>{const D=F.get(t),H=D&&D.count>0?D.sum/D.count:0,U=H*.2;return{hash:t,effectiveScore:y+U,rawScore:y,avgSymmetry:H}}).sort((t,y)=>y.effectiveScore-t.effectiveScore);for(const{hash:t,effectiveScore:y,rawScore:D,avgSymmetry:H}of q)(y>=.5||D>=.35&&H>=.7)&&T.add(t);const L=Math.min(100,Math.floor(c.length*.05)),I=Math.max(...f.values(),1);for(const[t,y]of f){if(t===i||T.has(t))continue;const D=F.get(t),H=D&&D.count>0?D.sum/D.count:0,U=y/I,V=H>=.6?Math.floor(L*.7):L;if(y>=V||U>=.5){T.add(t);const A=y/(s.get(t)||y),j=N.get(t)||0;N.set(t,Math.max(j,A))}}const w=Array.from(T),v=[],a=[],r=[];let m=0,k=0;const $=new Set(w),K=new Set;for(const t of e.values()){const y=t.confidenceSum/t.count;m=Math.max(m,t.count),k=Math.max(k,t.certainCount);const D=$.has(t.fromHash)||$.has(t.toHash),H=t.certainCount>=Lt,U=t.forwardCount+t.reverseCount,V=U>0?Math.min(t.forwardCount,t.reverseCount)/Math.max(t.forwardCount,t.reverseCount):0;let A="balanced";V<.7&&U>0&&(A=t.forwardCount>t.reverseCount?"forward":"reverse");const G=t.floodCount+t.directCount>0&&t.directCount>t.floodCount,ot=t.count>0?t.recencySum/t.count:0,Y={fromHash:t.fromHash,toHash:t.toHash,key:t.key,packetCount:t.count,avgConfidence:y,strength:0,avgRecency:ot,hopDistanceFromLocal:t.minHopDistance,isHubConnection:D,isCertain:H,certainCount:t.certainCount,forwardCount:t.forwardCount,reverseCount:t.reverseCount,symmetryRatio:V,dominantDirection:A,floodCount:t.floodCount,directCount:t.directCount,isDirectPathEdge:G};v.push(Y),H&&(a.push(Y),K.add(t.key))}for(const t of v)!K.has(t.key)&&t.packetCount>=se&&r.push(t);for(const t of v){const y=m>0?t.packetCount/m:0;t.strength=y*.4+t.avgConfidence*.4+t.avgRecency*.2}v.sort((t,y)=>y.certainCount-t.certainCount),a.sort((t,y)=>{const D=t.certainCount+(t.isHubConnection?1e3:0);return y.certainCount+(y.isHubConnection?1e3:0)-D}),r.sort((t,y)=>t.packetCount-y.packetCount);const X=a.slice(0,Nt),dt=r.slice(0,Nt),ut=new Map(v.map(t=>[t.key,t])),{loops:tt,loopEdgeKeys:J}=ce(a,i,k);for(const t of v)t.isLoopEdge=J.has(t.key);const Q=Jt(u,i),lt=ae(v,s,u,Q),st=re(Q,v),ht=fe(st,3,.3),{nodeMobility:it,mobileNodes:pt}=de(Q,l),Ct=le(Q,v,w,20),B=[];for(const t of P.values()){let y=null,D=0,H=0;for(const[U,V]of t.resolvedHashes){if(U===i)continue;const A=V.count>0?V.confidenceSum/V.count:0,j=V.count*A;j>D&&(D=j,y=U,H=A)}y&&B.push({hash:y,prefix:t.prefix,count:t.count,confidence:H,avgRssi:t.rssiCount>0?t.rssiSum/t.rssiCount:null,avgSnr:t.snrCount>0?t.snrSum/t.snrCount:null,lastSeen:t.lastSeen})}B.sort((t,y)=>y.count-t.count);let et=0,mt=0;const Ht=[],ft=[];let ct=0;for(const[t,y]of S){et+=y.confidence;const D=y.candidates.length;y.isUnambiguous||(mt++,ft.push({prefix:t,candidateCount:D}),y.confidence<.5&&Ht.push(t));for(const H of h.values())if(H.hash.toUpperCase().startsWith(t)||H.hash.slice(2).toUpperCase().startsWith(t)){ct+=H.resolutionCount;break}}ft.sort((t,y)=>y.candidateCount-t.candidateCount);const at=ft.slice(0,5),Ot={totalPrefixes:S.size,unambiguousPrefixes:S.size-mt,collisionPrefixes:mt,collisionRate:S.size>0?Math.round(mt/S.size*1e3)/10:0,avgConfidence:S.size>0?Math.round(et/S.size*1e3)/1e3:0,lowConfidencePrefixes:Ht,highCollisionPrefixes:at,totalResolutions:ct};return{edges:v,validatedEdges:X,weakEdges:dt,certainEdges:X,uncertainEdges:[],edgeMap:ut,maxPacketCount:m,maxCertainCount:k,neighborAffinity:o,fullAffinity:h,localPrefix:n,centrality:N,hubNodes:w,loops:tt,loopEdgeKeys:J,txDelayRecommendations:lt,pathRegistry:Q,edgeBetweenness:st,backboneEdges:ht,nodeMobility:it,mobileNodes:pt,pathHealth:Ct,lastHopNeighbors:B,disambiguationStats:Ot}}self.onmessage=c=>{const{type:l,payload:i}=c.data;if(l!=="compute"){self.postMessage({type:"error",error:`Unknown message type: ${l}`});return}const g=performance.now();try{const{packets:b,neighbors:C,localHash:M,localLat:u,localLon:S,airtimeMs:h}=i,n=ue(b,C,M,.5,u,S,h),o={edges:n.edges,validatedEdges:n.validatedEdges,weakEdges:n.weakEdges,certainEdges:n.certainEdges,uncertainEdges:n.uncertainEdges,maxPacketCount:n.maxPacketCount,maxCertainCount:n.maxCertainCount,localPrefix:n.localPrefix,hubNodes:n.hubNodes,edgeMapEntries:Array.from(n.edgeMap.entries()),neighborAffinityEntries:Array.from(n.neighborAffinity.entries()),fullAffinityEntries:Array.from(n.fullAffinity.entries()),centralityEntries:Array.from(n.centrality.entries()),loops:n.loops,loopEdgeKeyEntries:Array.from(n.loopEdgeKeys),txDelayRecommendationEntries:Array.from(n.txDelayRecommendations.entries()),pathRegistry:Qt(n.pathRegistry),edgeBetweennessEntries:Array.from(n.edgeBetweenness.entries()),backboneEdges:n.backboneEdges,nodeMobilityEntries:Array.from(n.nodeMobility.entries()),mobileNodes:n.mobileNodes,pathHealth:n.pathHealth,lastHopNeighbors:n.lastHopNeighbors,disambiguationStats:n.disambiguationStats},e=performance.now()-g,s={type:"result",payload:o,computeTimeMs:e};self.postMessage(s)}catch(b){const C={type:"error",error:b instanceof Error?b.message:"Unknown error in topology worker"};self.postMessage(C)}}})();
